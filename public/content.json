{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"倚楼听风雨，淡看江湖路(转)","text":"倚楼听风雨，淡看江湖路。但见泪痕湿，不知心恨谁！雪无踪，情亦无踪，雪无形，情亦无形。冬来，雪倾城，爱来情倾城。冬过，雪化水，爱过情化泪！ ——《风云》梦写给风的信 沧海桑田，天荒地老，不如有个人牵我的手，一起看夕阳老去。海枯石烂，天长地久，不如有个人陪我，倚楼听风雨，淡看江湖路。 前尘往事，都让他随风而逝了吧。红尘滚滚，都任他湮没在历史中去吧。硝烟弥漫，都让他消沉在尘世间里吧。 我，愿作世间素心人，本不想涉尘世太深的水而过，只愿独坐一隅，随世事流转，淡看红尘的故事，情感，梦想，琐碎的生活。 微风，淡淡的从陌上吹来，掠过窗前，我听到了他的叹息，那是岁月深处的感慨，似水流年，我们像花儿一样各自散落在了天涯。 朋友说，我总在碎碎念着悲伤，演绎着同样忧伤的爱情，落寞的思绪，寂寥的情愫，淡淡的情缘，浅淡的思念，痴恋的深情，心动的唯美，心碎的情殇…… 我，无法忘记让我最初心动的人，却是那份情愫在念念不忘的日子里，淡了。那时，我相信的一生只爱一个人的信念，也彻底崩溃在边缘了。 从此，我不知该怎么继续我的红尘情缘，人散，情淡，心性开始变得薄凉。细数流年，转身离开的日子，亦是很久很远了，这些年，寂寞一直汩汩流淌在心溪。 也许，我爱上了一个人，就爱上了寂寞，也爱上了文字。有人说，爱上了文字的孩子，苍老的比较快。因为心的沧桑。我想，我便如是所说。 所以，而今倚楼听风雨，悲欢离合总无情，一任阶前点滴到天明。淡看江湖路，人渐渐远去，情淡淡散去，但见泪痕湿，不知心爱谁。 红颜易老，情缘易醉，流光容易把人抛，惹了心绪，染了尘埃。良辰美景奈何天，泪水凉了心，才懂得，最后的疼爱是手放开。 温暖，刹那芳菲尽。悲伤，注入半世寂寞。我，不过是一个平凡的人，一杯又一杯的红尘酒，自斟自饮，醉了这一生，淡了红尘路。 青烟袅袅，那是心中挥之不去的忧伤。淡淡流云，那是心中无以言说的伤痛。风轻云淡，抹淡流年，静听雨声，洗尽芳华，愿你我安好。 轻轻地推开窗，沁人心脾的花香飘散在风雨中，扑鼻而来。温暖，依然在眼前，是我的心太多贪恋了。不如泡一杯茶，安于一份淡然。 也许，爱与不爱，都是殇。毕竟，我总觉得，爱是人间最美的情愫，心动的朦胧，抵得过心喜的痴恋自醉，心痛的黯然销魂。 其实，不是将他忘了，也不是讲故事忘了，更不是将情感忘了。虽然云淡风轻了，却依然是，多少事，才下眉头，却上心间。只是，选择三缄其口，不说了。 拈花一笑，捣碎了心，寂静转身，安然守候一丝一缕的情愫，如睡莲般静躺在红尘的流水里，即使，风雨穿透世事，亦波澜不惊。 夏夜微凉，窗外雨潺潺，随着旋律轻轻流泻指尖的忧伤，人淡情远，静静地坐着，想着心事，任红尘纷纭一一化了虚无，散了云烟，浅了风情。 搁浅心思，束之高阁，转身离开。如莲禅定，潜入红尘，出淤泥而不染。倚楼听风雨，淡看江湖路…… 作者：落叶链接：http://www.duwenzhang.com/wenzhang/xinqingriji/20140621/294982.html來源：文章阅读网","link":"/2017-08-13-%E5%80%9A%E6%A5%BC%E5%90%AC%E9%A3%8E%E9%9B%A8%EF%BC%8C%E6%B7%A1%E7%9C%8B%E6%B1%9F%E6%B9%96%E8%B7%AF/"},{"title":"一个简单的API授权流程","text":"实际项目中我们经常会碰到给第三方开放我们项目API的这种场景。这时我们要保证api的安全，参考腾讯广点通的api调用。现将php的代码实现整理这此。 我们的算法很简单： 把调用方自己的appid,secret_key,当前的时间戳time连接起来用sha1方法生成一个sign 把appid,time,sign用英文逗号连接并用base64打包变成一个参数token API的几个方法api_functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php/** * 生成token * @param string $appid * @param string $secret_key * @param int $time * @return string */function generate_token($appid, $secret_key, $time){ $sign = sha1($appid . $secret_key . $time); return base64_encode($appid . ',' . $time . ',' . $sign);}/** * 解包token * @param string $token * @return array */function unpack_token($token){ $params = base64_decode($token); $params = explode(',', $params); return [ 'appid'=&gt; isset($params[0]) ? $params[0] : '', 'time'=&gt; isset($params[1]) ? $params[1] : '', 'sign'=&gt; isset($params[2]) ? $params[2] : '', ];}/** * @param $url * @param array $data * @param bool $is_post * @param array $header * @return mixed */function sub_curl($url, $data = array(), $is_post = false, $header = array()){ $ch = curl_init(); if (!$is_post &amp;&amp; !empty($data)) { $url = $url . '?' . http_build_query($data); } curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, $is_post); if ($is_post) { curl_setopt($ch, CURLOPT_POSTFIELDS, $data); } curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 20); if (!empty($header)) { curl_setopt($ch, CURLOPT_HTTPHEADER, $header); } $info = curl_exec($ch); $code = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($code != 200){ echo_json($code, 'api调用出错'.$code); } curl_close($ch); return $info;}/** * @param int $code * @param string $msg * @param array $data */function echo_json($code, $msg = '', $data = array()){ header('Content-type:application/json'); echo json_encode(array('ret' =&gt; $code, 'msg' =&gt; $msg, 'data' =&gt; $data)); exit;} API提供方api.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phprequire 'api_functions.php';//授权的使用方名单 现为演示方便直接使用数组$users = [ 'user_001'=&gt;[ 'appid'=&gt;'user_001', //使用方对于提供方api的唯一id 'secret_key'=&gt;'97bc847d4ea7dd9f035d41a657302f1c' //密钥 也唯一 ], 'user_002'=&gt;[ 'appid'=&gt;'user_002', 'secret_key'=&gt;'c763b64a62186ae6831edd22063539c4' ], 'user_003'=&gt;[ 'appid'=&gt;'user_003', 'secret_key'=&gt;'51a683bea5e5c138fd0342fb70e03c65' ],];//检验签名$token = isset($_GET['token']) ? trim($_GET['token']) : '';if(empty($token)){ echo_json(1000, 'token missed');}//解包token$token_params = unpack_token($token);if(empty($token_params['sign'])){ echo_json(1001, 'sign error'); //签名为空或者错误}if(empty($token_params['appid'])){ echo_json(1002, 'appid error'); //appid为空或者错误}if(empty($token_params['time'])){ echo_json(1003, 'time error'); //time为空或者错误}if(abs($token_params['time'] - time()) &gt; 10 * 60){ // api 调用时间限制左右浮动10分钟 echo_json(1004, 'time expired'); // 10 minutes}//用appid取用户$user = isset($users[$token_params['appid']]) ? $users[$token_params['appid']] : [];if(empty($user)){ echo_json(1005, 'appid not exists'); //调用方不存在}//使用调用方参数生成token$create_token = generate_token($user['appid'], $user['secret_key'], $token_params['time']);if($token !== $create_token){ echo_json(1006, 'token error'); //token错误}//到此 调用权限的验证就ok了$api = isset($_GET['api']) ? trim($_GET['api']) : '';//接下来你可以有其他对具体接口的验证...//返回结果echo_json(200, 'your request api '.$api. ' success!'); API调用方use_api.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phprequire 'api_functions.php';//假设使用方是 user_001 他拥有自己的appid和secret_key$user = [ 'appid' =&gt; 'user_001', //使用方对于提供方api的唯一id 'secret_key' =&gt; '97bc847d4ea7dd9f035d41a657302f1c' //密钥 也唯一];//生成token$token = generate_token($user['appid'], $user['secret_key'], time());//url换成你自己的接口url$url = 'http://' . $_SERVER['HTTP_HOST'] . dirname($_SERVER['REQUEST_URI']);$url .= '/api.php?api=user_info'; //调用user_info的接口$url .= '&amp;token=' . $token;echo $url;echo '&lt;hr&gt;&lt;pre&gt;';//请求接口$res = sub_curl($url);var_dump(json_decode($res, 1));/* 调用成功结果array(3) { [\"ret\"]=&gt; int(200) [\"msg\"]=&gt; string(35) \"your request api user_info success!\" [\"data\"]=&gt; array(0) { }}*/","link":"/2017-08-16-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84api%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B/"},{"title":"用PHP进行HTTP认证","text":"PHP的HTTP认证机制，就是用header()函数来向客户端浏览器发送“Authentication Required”信息，使其弹出一个用户名／密码输入窗口。当用户输入用户名和密码后，包含有URL的PHP脚本将会加上预定义变量PHP_AUTH_USER，PHP_AUTH_PW和AUTH_TYPE被再次调用，这三个变量分别被设定为用户名，密码和认证类型。预定义变量保存在 $_SERVER 或者 $HTTP_SERVER_VARS 数组中。支持“Basic”和“Digest”（自 PHP 5.1.0 起）认证方法。这是php官网的解释。大家看示例体会。😁 参考连接：http://php.net/manual/zh/features.http-auth.php 示例：1234567891011121314&lt;?phpif (!isset($_SERVER['PHP_AUTH_USER'])) { header('WWW-Authenticate: Basic realm=\"My Realm\"'); header('HTTP/1.0 401 Unauthorized'); die('401 Unauthorized'.'&lt;br&gt; &lt;button onclick=\"window.location.reload();\"&gt;Login Again&lt;/button&gt;');} else { if($_SERVER['PHP_AUTH_USER'] !== 'James Bond' || $_SERVER['PHP_AUTH_PW'] !== '007'){ header('WWW-Authenticate: Basic realm=\"My Realm\"'); header('HTTP/1.0 401 Unauthorized'); die('401 Unauthorized'.'&lt;br&gt; &lt;button onclick=\"window.location.reload();\"&gt;Login Again&lt;/button&gt;'); }}//下面是你的业务代码 这样就会弹出一个登陆框，输入用户名：James Bond 密码：007 登陆吧！ 成功了没，哈哈，大家觉得是不是很好玩~","link":"/2017-08-21-%E7%94%A8PHP%E8%BF%9B%E8%A1%8CHTTP%E8%AE%A4%E8%AF%81/"},{"title":"九月，加油！","text":"不知不觉这一年已经过了大半。九月了，加油！","link":"/2017-09-06-%E4%B9%9D%E6%9C%88%EF%BC%8C%E5%8A%A0%E6%B2%B9/"},{"title":"一个百度地图的常用使用示例","text":"今天在项目中用到了百度地图，感觉也是个基本用法的常用示例，在这和大家分享下😁 效果如图： 先说说需求吧： 打开地图，自动定位到当前所在位置，并在地图上添加一个可拖拽的标注（marker） 用户可以拖拽标注选择地图上的位置，同时标注的经纬度显示在input框中（其实这个是为了看效果，一般都用隐藏域），标注的当前地址显示在地址的输入框中 用户输入地址之后自动调用百度地图的API，找到输入地址对应到地图的点并移动标注到此。当然也包括显示经纬度。 HTML页面部分是这样子，使用bootstrap3的样式 12345678910111213141516171819202122&lt;div class=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-lg-2 col-sm-2 control-label\"&gt;地址&lt;/label&gt; &lt;div class=\"col-lg-10\"&gt; &lt;input type=\"text\" class=\"form-control pwd-input\" name=\"address\" id=\"address\" value=\"&lt;?php echo !empty($info['address']) ? $info['address'] : '';?&gt;\" placeholder=\"请输入地址\"&gt; &lt;p class=\"help-block\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-lg-2 col-sm-2 control-label\"&gt;选择位置&lt;/label&gt; &lt;div class=\"col-lg-10\"&gt; &lt;div class=\"clearfix\"&gt; &lt;label class=\"control-label pull-left\" style=\"margin-right: 5px;\"&gt;经度&lt;/label&gt;&lt;input type=\"text\" name=\"lng\" id=\"lng\" value=\"&lt;?php echo !empty($info['lng']) ? $info['lng'] : '';?&gt;\" class=\"form-control pull-left\" style=\"width: 120px;margin-right: 15px;\"&gt; &lt;label class=\"control-label pull-left\" style=\"margin-right: 5px;\"&gt;维度&lt;/label&gt;&lt;input type=\"text\" name=\"lat\" id=\"lat\" value=\"&lt;?php echo !empty($info['lat']) ? $info['lat'] : '';?&gt;\" class=\"form-control pull-left\" style=\"width: 120px;\"&gt; &lt;/div&gt; &lt;br&gt; &lt;div id=\"l-map\" style=\"width: 600px;height: 400px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 重点是js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//经纬度var lat = '&lt;?php echo !empty($info['lat']) ? $info['lat'] : '';?&gt;';var lng = '&lt;?php echo !empty($info['lng']) ? $info['lng'] : '';?&gt;';// 百度地图API功能var map = new BMap.Map(\"l-map\"); //new个地图出来var point;var marker;if(lat &amp;&amp; lng){ point = new BMap.Point(lng,lat); //new个点 marker = new BMap.Marker(point); //new个标注 marker.enableDragging(); // 可拖拽 map.addOverlay(marker); // 将标注添加到地图中 getPosition(marker);}else{ point = new BMap.Point(107.475903, 31.214995); //map.addControl(new BMap.GeolocationControl()); //定位 map.addControl(new BMap.NavigationControl()); var geolocation = new BMap.Geolocation(); //获取当前位置 geolocation.getCurrentPosition(function(r){ if(this.getStatus() == BMAP_STATUS_SUCCESS){ marker = new BMap.Marker(r.point); marker.enableDragging(); // 可拖拽 map.addOverlay(marker); map.panTo(r.point); //console.log('您的位置：'+r.point.lng+','+r.point.lat); getPosition(marker); } else { marker = new BMap.Marker(point); marker.enableDragging(); // 可拖拽 map.addOverlay(marker); // 将标注添加到地图中 getPosition(marker); } },{enableHighAccuracy: true});}map.centerAndZoom(point, 12);var gc = new BMap.Geocoder();//地址解析类//地址输入框失去焦点时搜索输入的位置$(\"#address\").blur(function(){ var address = $(this).val(); parseAddress(address, '上海市');});//解析地址function parseAddress(address, city){ gc.getPoint(address, function(point){ console.log(point); if(point){ //放大地图 之前zoom是12 map.setZoom(15); // console.log(marker); $(\"#lng\").val(point.lng); $(\"#lat\").val(point.lat); //接下来的操作想想应该时移动标注到新的位置，但是好像api没这中操作，只有先把标注从地图上取下来 换个位置再放上去 var allOverlay = map.getOverlays(); //获取地图覆盖物 //console.log(allOverlay); for(var i = 0;i&lt;allOverlay.length;i++) { var pos = allOverlay[i].getPosition(); //删除指定经度的覆盖物 if (pos &amp;&amp; pos.lng == point.lng &amp;&amp; pos.lat == point.lat) { map.removeOverlay(allOverlay[i]); } } //重设标注的位置 marker.setPosition(point); //把标注重新放到地图上 map.addOverlay(marker); //移动地图到新位置 map.panTo(point); } }, city);}function getPosition(marker){ //添加标记点击监听 marker.addEventListener(\"mouseup\", function(e){ gc.getLocation(e.point, function(rs){ //console.log(\"地图中心点变更为：\" + rs.lng + \", \" + rs.lat); console.log(rs.point.lat + ',' + rs.point.lng); $(\"#lng\").val(rs.point.lng); $(\"#lat\").val(rs.point.lat); $(\"#address\").val(rs.address); }); });} 其实基本的操作还挺顺利的，只是在一个地方碰到了坑：移动标注 怎么移动呢？翻了百度API没找到，最后也是通过搜素引擎查查查，才找到思路。 原来标注添加标注(marker)添加到地图上是属于覆盖物(Overlay)。想移动就换个思路，把这个覆盖物移除，然后重新给标注赋予新的位置属性，然后重新添加到地图上。 (。・∀・)ノ 这下搞定啦~ 赶紧关机下班，庆祝一下 🎉","link":"/2017-09-07-%E4%B8%80%E4%B8%AA%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"},{"title":"自己实现AJAX异步上传文件","text":"在项目中经常用到文件上传，然后就找各种各样的插件。但用着用着总不是很多地方不是很称手，需要修修改改。所以今天干脆自己写个吧。 先说说具体需求： 上传文件做到所见所得，就是选择文件之后能立马看到 可以方便用在用js异步提交的表单中 HTML页面部分是这样子 123456&lt;div&gt; &lt;!-- 图片./images/add_img.png就是一个很大的加号 + --&gt; &lt;img style=\"cursor: pointer;\" src=\"./images/add_img.png\" alt=\"点击上传\" width=\"100\" title=\"点击上传\" class=\"upload-img\" data-id=\"img\"&gt; &lt;input type=\"hidden\" name=\"image\" value=\"\" class=\"upload-img-input\" data-id=\"img\"&gt; &lt;input style=\"display: none\" type=\"file\" accept=\"image/gif,image/jpeg,image/jpg,image/png,image/bmp\" name=\"file\" id=\"file_img\" data-id=\"img\" onchange=\"upload_image(this);\"&gt;&lt;/div&gt; 在input:file的accept属性中定义可以上传的文件格式（MIME 类型）在这里我们列出常用的图片类型：image/gif,image/jpeg,image/jpg,image/png,image/bmp 其实在这大家会说后缀是.jpg和.jpeg的图片的mime type不都是image/jpeg吗？为什么还要加个image/jpg? 没错，是这样如果你只写image/jpeg用谷歌浏览器是没问题的。但是在微信浏览器，QQ浏览器中就不行了，后来找不到问题，尝试了好多次才发现这个问题。没办法，国产浏览器不按标准造的原因 ╮(╯▽╰)╭ 其他文件格式大家看这里 w3school 重点是js： 12345678910111213141516171819202122232425262728293031323334353637383940//点击图片的时候 触发隐藏的input:file的点击事件$(\".upload-img\").click(function(){ var id = $(this).data('id'); var file = document.getElementById('file_' + id); file.click();});function upload_image(pic_file) { var id = $(pic_file).data('id'); var input = $(\"input.upload-img-input[data-id=\"+id+\"]\"); //找到相应的隐藏域 var pic = $(\"img.upload-img[data-id=\"+id+\"]\"); //找到相应的预览图片 var file = pic_file.files[0]; if (file.size &gt; 2 * 1024 * 1024) { //设置限制文件大小 不大于2MB alert('上传文件不能大于2M!'); return false; } var fd = new FormData(); //使用formData对象 fd.append(\"pic_file\", file); //fd.append(\"name\", name); //可以添加其他字段，比如有些框为了安全加的csrf_token var xhr = new XMLHttpRequest(); xhr.open(\"POST\", 'upload_file.php'); //这里是后端处理的地址 xhr.onload = function () { if (xhr.status == 200) { var obj = eval('(' + xhr.responseText + ')'); //把json字符串转换成js对象 if (obj.ret == 200) { //上传成功 var pic_url = obj.data.url; //显示预览图 input.val(pic_url); //把地址放到隐藏域 pic.attr('src', pic_url); } else { alert(obj.msg); } } else { alert('上传失败，请稍候再试'); } }; xhr.send(fd);} 我们服务端上传返回的json格式是这样 1234567{ \"ret\": 200, \"msg\": \"ok\", \"data\": { \"url\": \"你的图片url地址\" }}","link":"/2017-09-09-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0AJAX%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"title":"EFI模式下安装win10+Archlinux","text":"就最近一次安装Archlinux做一次笔记吧。别问我为什么没事就装arch，因为他是arch 😜 Win10安装就略过了，我的电脑linux老换，win10始终稳稳的在那躺着，一动不动。。。 因为win10是提前安装好的，而他是使用EFI模式安装的 我们在win10下在硬盘上给咋arch挪出点空间来，几十个GB就行。看你硬盘大小了和心情了。 启动liveCD用在官网或者163源下载最新的liveCD镜像（比如最新是archlinux-2017.09.01-x86_64.iso），刻录到u盘，我喜欢用rufs，这个不大于1M的小工具很简单强大我喜欢。 当然了，熟悉linux的同学可以用dd命令。 插上u盘，重启到liveCD里面。里面也是个没桌面的shell系统。 看Archlinux wiki在开始之前最好还是看看arch的wikiInstallation guide(安装指南)，写的很详细，最好看英文的，中文的翻译有点延迟。 联网如果你是有线网络，插上网线，启动dhcpd服务（也就是动态获取ip） 1systemctl start dhcpcd 无线网络用wifi-menu链接 1wifi-menu 看看链接成功了没 查看下ip 1ip addr 如果没成功，或者其他的联网方式，看看arch的wiki 其实说到这，再次提醒大家，看arch的wiki 连上网络了，开工吧! 分区：1fdisk /dev/sda 进入fdisk之后按p，看看现有分区的情况这是我的硬盘分区情况，硬盘格式gpt 123456/dev/sda1 2048 923647 921600 450M Windows 恢复环境/dev/sda2 923648 1128447 204800 100M EFI 系统/dev/sda3 1128448 1161215 32768 16M Microsoft 保留/dev/sda4 1161216 209256750 208095535 99.2G Microsoft 基本数据/dev/sda5 209258496 210888703 1630208 796M Windows 恢复环境/dev/sda6 210890752 462559542 251668791 120G Microsoft 基本数据 假如我的硬盘中空闲空间100GB，用fdisk 给这100GB分一分 我的方案是： 123/dev/sda7 /boot ext4 500MB #boot启动分区 500MB够用了/dev/sda8 swap 8GB #交换分区， 我的内存也8GB，我就分一样大小了/dev/sda9 / ext4 #剩下的全给 / 根分区 根据自己的空间大小自行调整。 格式化： 123mkfs.ext4 /dev/sda7mkfs.ext4 /dev/sda9mkswap /dev/sda8 安装基础系统挂载分区： 123456mount /dev/sda9 /mntmkdir /mnt/bootmount /dev/sda7 /mnt/bootmkdir /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI #这个EFI分区在分区情况里面能看到我的是sda2swapon /dev/sda8 修改源： 1vim /etc/pacman.d/mirrorlist 把163，ustc这几个比较好使的中国源复制到文件最上面，到时候下载安装的时候跑的快一点 开始安装： 1pacstrap -i /mnt base vim dialog wpa_supplicant base是基础系统，dialog是上面提到的链接无线网的wifi-menu，wpa_supplicant也是手动链接无线网的包，vim 不解释 安装完成之后 把分区挂载情况写入fstab中： 1genfstab -U -p /mnt &gt; /mnt/etc/fstab chroot进新系统： 1arch-chroot /mnt /bin/bash 一些配置： 1234567echo &apos;my-archlinux&apos; &gt; /etc/hostname #设置主机名字ln -sf /usr/share/zoneinfo/Asia/Shanghai #设置时区timedatectl set-timezone Asia/Shanghai #也可以用这个设置时区timedatectl set-ntp true # 设置时间ntp同步网络时间vim /etc/locale.gen # 区域设置 取消英文（en_US.UTF-8）和中文(zh_CN.UTF-8)的注释locale-gen #生成设置区域设置echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf #设置语言，因为先安装的是没桌面的模式，先用英文，中文会显示成小方块 创建初始内存盘mkinitcpio 1mkinitcpio -p linux 设置root密码 1passwd 这步忘了，你就进不去系统了，╮(╯▽╰)╭ 搞定启动项： 1234pacman -S grub efibootmgr #安装grub efibootmgr管理启动项grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=arch_grub --recheckpacman -S os-prober #安装这个包是为了让grub-mkconfig发现win10的启动项grub-mkconfig -o /boot/grub/grub.cfg #把启动项写到文件配置里 如果win10的启动项没有被发现，不要着急，在新的系统安装重启之后，重新执行上面grub-mkconfig命令就行了 退出新系统,重启 123exit #退出unmout -R /mnt #取消挂载磁盘reboot #重启 好了如果一切顺利，重启之后就能看到你的新系统了 (。・∀・)ノ","link":"/2017-09-13-EFI%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AE%89%E8%A3%85win10+Archlinux/"},{"title":"Win10子系统ubuntu更换源","text":"作为一个windows下面的开发者，之前工作一直用cygwin。cygwin虽然方便但是很多时候安装一些东西，比如jekyll,是各种依赖不足，太痛苦了。好在微软win10出了针对开发者的linux子系统，那就先试用一段时间吧。 现在win10的linux子系统已经有ubuntu和opensuse两个版本了,应该后续还会推出更多的linux发行版。大家按个人喜好安装吧。 安装过程，网上很多也不难，就略过了，大家自行搜索吧。 我的linux子系统用的是ubuntu，使用起来简单方便啊😁 安装完成之后，顺手就是一个 apt update，但是默认的源太慢了，没法忍。那我们就换国内源吧。 国内有好多源，阿里云，163，搜狐，中科大等等。我们就以阿里云做个例子吧： 浏览器打开 http://mirrors.aliyun.com/ 找到ubuntu的help 发现里面最新的是 Quantal(12.10) 看来不能直接复制 在你的子系统bash中执行 123456cat /etc/apt/sources.list-------------------------deb http://archive.ubuntu.com/ubuntu/ xenial main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse------------------------- 索性最新版ubuntu16.04代号叫xenial 那直接把url换换就行了 1234567sudo cp /etc/apt/sources.list /etc/apt/sources.list.bk # 改配置文件，先备份是个好习惯sudo vim /etc/apt/sources.list # 把内容换成下面的就行了，其实就是url变了-------------------------deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse------------------------- 搞定了，测试下： 1sudo apt update 没问题就可以了。","link":"/2017-09-17-win10%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu%E6%9B%B4%E6%8D%A2%E6%BA%90/"},{"title":"MSYS2初体验","text":"作为一名windows下面开发者，之前工作Cygwin做为辅助。前些天突然发现了一个叫MSYS2的家伙。 发现这家伙还不错，这是百度百科的介绍： MSYS2 （Minimal SYStem 2） 是一个MSYS的独立改写版本，主要用于 shell 命令行开发环境。同时它也是一个在Cygwin （POSIX 兼容性层） 和 MinGW-w64（从”MinGW-生成”）基础上产生的，追求更好的互操作性的 Windows 软件。MSYS2 是MSYS的一个升级版,准确的说是集成了pacman(我喜欢叫吃豆人)和Mingw-w64的Cygwin升级版, 提供了bash shell等linux环境、版本控制软件（git/hg）和MinGW-w64 工具链。与MSYS最大的区别是移植了 Arch Linux的软件包管理系统 Pacman(其实是与Cygwin的区别)。 看起来还不错，这是官网 安装就下载二进制安装程序安装就可以了。 安装之后急切地 pacman -Sy 刷新软件包数据，官网的源还有点慢。换中科大的源吧。 1234cd /etc/pacman.dls-------------------gnupg mirrorlist.mingw32 mirrorlist.mingw64 mirrorlist.msys 三个mirrorlist开头的文件就是源的配置文件 编辑 /etc/pacman.d/mirrorlist.mingw32 ，在文件开头添加： 1Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686 编辑 /etc/pacman.d/mirrorlist.mingw64 ，在文件开头添加： 1Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64 编辑 /etc/pacman.d/mirrorlist.msys ，在文件开头添加： 1Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch 然后执行 pacman -Sy 刷新软件包数据即可。 还有一点，cygwin切换系统磁盘是 1cd /cygdrive/d/ #比如切换到d盘 MYSYS2是： 1cd /d 使用windows原生命令比如ping会中文乱码，这么解决： 新建 /bin/win： 12#!/bin/bash$@ |iconv -f gbk -t utf-8 使用： 1/bin/win ping baidu.com","link":"/2017-09-22-MSYS2%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"搭建Git服务器、编写自动部署脚本","text":"今天试了下在linux服务器上搭建Git服务器，并且编写一个简单的自动部署脚本。 主要参考 廖雪峰-GIT教程-搭建Git服务器 现在开始吧！ 创建一个git用户，用来运行git服务1adduser git 创建证书登录收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 初始化Git仓库先选定一个目录作为Git仓库，假定是/home/git/sample.git，在/home/git目录下输入命令 1git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git 1chown -R git:git sample.git 禁用git用户shell登录通过编辑/etc/passwd文件完成，找到你的git用户的一行,例如 1git:x:1001:1001:,,,:/home/git:/bin/bash 把/bin/bash改为/usr/bin/git-shell,例如 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 克隆远程仓库1git clone git@server:sample.git server是你的服务器域名或ip地址 如果git仓库和web目录在同一台服务器主机上: 1git clone /home/git/sample.git 如果不是在git用户的家目录中创建的,比如/srv/gits/sample.git： 1git clone git@server:/srv/gits/sample.git 如果clone成功，那么你的git服务器就搭建成功了。 接下来： 自动同步钩子脚本因为我是web目录和git是同一台服务器 编辑 /home/git/sample.git/hooks/post-receive, post-receive就是在git服务器收到代码推送后(push完成之后)执行的脚本。 1234567891011121314#!/bin/shwhile read oldrev newrev refnamedo branch=$(git rev-parse --symbolic --abbrev-ref $refname) if [ &quot;master&quot; == &quot;$branch&quot; ]; then # Do something echo &quot;post-receive in branch master&quot; &gt;&gt; /tmp/git-sample.log unset GIT_DIR wwwPath=/var/www/html/sample cd $wwwPath &amp;&amp; /usr/bin/git pull origin master exit 0 fidone 从脚本内容可以看出，我们在判断当前push的分支是master时执行git pull origin master操作。 给执行权限 12chown -R git:git /home/git/sample.git/hooks/post-receivechmod +x /home/git/sample.git/hooks/post-receive 因为是git仓库和web目录在同一台服务器主机上,这里clone使用的是: 1git clone /home/git/sample.git 因为同步脚本的执行用户是git，所以要保证项目目录要赋予git写权限。容易出问题的也是权限问题。 好了，试试吧~","link":"/2017-09-29-%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/"},{"title":"Docker基础命令","text":"最近忙里偷闲研究了下docker这个很火的东东。做点笔记😁 镜像列出镜像列表 1docker images 获取一个新的镜像 1docker pull base/archlinux 删除镜像 1docker rmi imageID 查找镜像 1docker search php 构建 12cd /path/to/Dockerfiledocker build -t imageName ./ 容器1docker run base/archlinux /bin/echo &quot;hello world&quot; 运行交互式的容器 1docker run -i -t base/archlinux /bin/bash * -t:在新容器内指定一个伪终端或终端。 * -i:允许你对容器内的标准输入 (STDIN) 进行交互。分配端口 12docker run -P php7.0-app #自动分配docker run -p 5000:80 #容器内部的 80 端口映射到主机的 5000 端口上 查看正在运行的容器 12docker psdocker container ls #或者 查看端口 1docker port containerID/contaienrName 查看日志 12docker logs docker -f containerID/contaienrName 查看进程 1docker top containerID/contaienrName 查看Docker的底层信息 1docker inspect containerID/contaienrName 停止容器 1docker stop containerID/contaienrName 启动容器 1docker start containerID/contaienrName 正在运行的容器，我们可以使用 docker restart 命令来重启 查看最后一次创建的容器 1docker ps -l 移除容器 1docker rm containerID/contaienrName","link":"/2017-10-26-Docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"title":"使用docker玩转php开发环境","text":"还是忙里偷闲研究了下怎么用docker这个东东来整php开发。做点笔记😁 先看Dockerfile: 12345678# 使用基于alpine linux 的镜像，体积小，下载快FROM php:7.0-cli-alpine# 使用中科大的源加快下载速度RUN sed -i &apos;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&apos; /etc/apk/repositories# 安装下基本的php扩展RUN docker-php-ext-install pdo pdo_mysql mysqli 构建1docker build -t heropoo/php-cli-alpine . #先切换到你的Dockerfile目录 运行1docker run -it --rm --name php-cli-server -p 8080:80 -v //c/Users/ttt/www:/usr/src/www -w /usr/src/www php:7.0-cli-alpine php -S 0.0.0.0:80 这句好长啊，解释下各个参数： -t在新容器内指定一个伪终端或终端 -i 允许你对容器内的标准输入 (STDIN) -p 映射宿主机端口到容器的端口，上面就是宿主机的8080到容器的80 -v 挂载宿主机目录到容器的目录，上面就是宿主机/c/Users/ttt/www到容器/usr/src/www -w 设置工作目录 –rm 容器运行完之后删除 –name 给容器名字 php -S 0.0.0.0:80 就是用php内置的服务器启动一个web服务了，简单点来 哈哈 我系统是windows，我在浏览器访问docker的web服务：http://ip:8080,ip是你的docker的ip,就可以了。 是不是很好玩😜","link":"/2017-11-16-%E4%BD%BF%E7%94%A8docker%E7%8E%A9%E8%BD%ACphp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"百度UEditor自定义上传地址","text":"之前有个小朋友问我百度UEditor怎么自定义服务端上传地址, 正好也用过，现在做下笔记吧。 在ue实例化的时候你服务端上传的请求地址赋值给serverUrl 12345678910111213141516171819var ue;ue = UE.getEditor('editor', { toolbars: [ //这个是工具栏配置，自己定义和今天主题无关 [ 'fullscreen', 'source', '|', 'undo', 'redo', '|', 'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|', 'directionalityltr', 'directionalityrtl', 'indent', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', '|', 'touppercase', 'tolowercase', '|', 'link', 'unlink', 'anchor', '|', 'imagenone', 'imageleft', 'imageright', 'imagecenter', '|', 'simpleupload', '|', 'pagebreak', 'template', 'background', '|', 'horizontal', 'date', 'time', 'spechars', 'snapscreen', 'wordimage', '|', 'inserttable', 'deletetable', 'insertparagraphbeforetable', 'insertrow', 'deleterow', 'insertcol', 'deletecol', 'mergecells', 'mergeright', 'mergedown', 'splittocells', 'splittorows', 'splittocols', 'charts', '|', 'preview' ] ], serverUrl: 'http://your-server-address' //这里是你服务端上传的请求地址}); 在上面自定义了服务端地址之后，我们刷新页面，ue实例化的时候会自动请求你的地址并且带着query参数，大概是这样：http://your-server-address?action=config。这是ue实例化会请求配置文件，简单点你可以直接返回ue插件文件夹中ueditor/1.4.3.3/php/config.json的内容就可以了。当然了具体配置你是可以自己按自己需求改动。 接下来上传图片，随便上传一张图片，会发现ue的请求地址是http://your-server-address?action=uploadimage。这样是不是恍然大悟： action参数是config，你就给他返回配置内容; action参数是uploadimage就是图片上传，你就保存图片文件，返回成功或者失败的结果。 上传结果返回格式是这样的： 失败的情况 1234{ \"state\": \"Failed\", \"msg\": \"error msg\"} 成功的情况 123456789{ \"state\": \"SUCCESS\", \"msg\": \"ok\", \"original\": \"aaa.jpg\", //图片源文件名 \"type\": \".jpg\", //图片后缀 \"size\": 10240000, //图片大小 \"title\": \"aaa\", //图片img标签上的属性title \"url\": \"/upload/fsf3r.jpg\" //图片上传之后的url} 好了就这样","link":"/2017-10-26-%E7%99%BE%E5%BA%A6ueditor%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%BC%A0%E5%9C%B0%E5%9D%80/"},{"title":"2018,新年快乐！","text":"2018年了，新年快乐！ 加油！","link":"/2018-01-01-2018-happy-new-year/"},{"title":"整理几个常用的国内源","text":"Linux以及一些开源软件一些企业的： 网易开源镜像站 http://mirrors.163.com/ 搜狐开源镜像站 http://mirrors.sohu.com/ 阿里云源镜像站 http://mirrors.aliyun.com/ 首都在线 http://mirrors.yun-idc.com/ 各大高校的： 中科大开源镜像站 http://mirrors.ustc.edu.cn/ 清华大学开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/ 华中科技大学开源镜像站 http://mirror.hust.edu.cn/ 浙江大学开源镜像站 http://mirrors.zju.edu.cn/ 东软信息学院开源镜像站 http://mirrors.neusoft.edu.cn/ 北京理工大学开源软件镜像 http://mirror.bit.edu.cn/ 北京交通大学自由与开源软件镜像站 https://mirror.bjtu.edu.cn/ 兰州大学开源社区镜像站 http://mirror.lzu.edu.cn/ 上海交通大学 http://ftp.sjtu.edu.cn/ 东北大学 http://mirror.neu.edu.cn/ js npm 淘宝NPM镜像 http://npm.taobao.org/ php composer Composer中文网 http://www.phpcomposer.com/ LaravelChina社区提供的镜像地址： https://packagist.laravel-china.org Docker DaoCloud http://a42abd64.m.daocloud.io 阿里云 要注册独立分配 传送门 大概就整理这么多了，至于各个镜像的更换方法大家根据自己的应用自行百度吧~","link":"/2018-01-20-cn-mirrors/"},{"title":"如果编程语言是一种武器(转自互联网)","text":"对程序员来说，编程语言就是武器，但有的武器好用，有的武器不好用，有的武器甚至会杀了自己 C语言是M1式加兰德步枪，很老但可靠。 C++是双截棍，挥舞起来很强悍，很吸引人，但需要你多年的磨练来掌握，很多人希望改用别的武器。 Perl语言是燃烧弹，曾经在战场上很有用，但现在很少人使用它。 Java是M240通用弹夹式自动机枪，有时它的弹夹是圆的，但有时候不是，如果不是，当你开火时，会遇到NullPointerException问题，枪就会爆炸，你被炸死。 Scala是M240通用机枪的变种，但它的使用手册是用一种看不懂的方言写的，很多人怀疑那只是一些梦话。 JavaScript是一把宝剑，但没有剑柄。 Go语言是一种自制的”if err != nil”发令枪，每一次发射后，你都必须要检查它是否真的发射了。 Rust语言是一种3D打印出的枪。将来也许真的能派上用场。 bash是一个十分碍手的锤子，你抡起它时会发现所有东西看起来都像钉子，尤其是你的指头。 Python是一种”v2/v3”双管枪，每次只能用一个管子发射，你永远不知道该用哪个管子发射好。 Ruby是一把外嵌红宝石的宝刀，人们使用它通常是因为看起来很炫。 PHP是水管子，你通常会把它的一段接到汽车的排气管，另一端插进车窗里，然后你坐进车里，开动引擎。 Mathematica是一种地球低轨道粒子大炮，它也许能够干出很神奇的事情，但只有付得起费用的人才能使用它。 C#是一种强悍的激光大炮，架子一头驴子上，如果从驴子上卸下来，它好像就发不出激光。 Prolog语言是一种人工智能武器，你告诉它要做什么，它会照做不误，但之后，它会弄几个终结者出来，烧掉你的房子。 Lisp语言是一把剃须刀，有很多款式。只有寻求刺激和危险的人才会使用它。","link":"/2018-01-23-If-the-programming-language-is-a-weapon/"},{"title":"Git的一些基本操作【持续更新】","text":"经常用git，但好多命令总是记不住，每次都百度。现在整理下做个笔记吧。 分支操作 查看分支 12git branch #只显示本地分支git branch -a #显示本地分支和远程分支 创建分支 12git checkout -b branch_name#如果有一个远程分支remotes/origin/branch_name,那么执行这个命令将会创建新的名为`branch_name`本地分支并且跟踪同名的远程分支remotes/origin/branch_name 推送远程分支 1git push origin branch_name 删除分支 123git branch -d branch_name# 删除本地分支后并删除远程分支git push --delete origin branch_name tag 标签操作 查看tag列表 1git tag 新增tag 1git tag tag_name # 比如v1.0 推送本地指定tag到远程 1git push origin tag_name 推送全部本地tag到远程 1git push --tags 删除tag 123git tag -d # 删除tag后并删除远程taggit push --delete origin tag_name github中fork的项目与原作者同步假如一个项目Evil-S0ul/write-doc地址: https://github.com/Evil-S0ul/write-doc 我fork之后的项目是heropoo/write-doc地址: https://github.com/heropoo/write-doc 接下来开始操作： 切换到我fork的项目目录里，然后增加源仓库地址到你项目的远程分支中12cd write-docgit remote add Evil-S0ul https://github.com/Evil-S0ul/write-doc fetch刚添加的源分支到本地1git fetch Evil-S0ul 合并两个版本的代码1git merge Evil-S0ul/master 最后把合并后的代码push到你的Github项目上去就ok啦1git push origin master 检出远程的某个分支或者tag1234git fetchgit checkout branch_name#或者git checkout tag_name 同步且merge其他远程分支到当前本地分支1git pull origin other_branch_name Git无法pull仓库refusing to merge unrelated histories有时候我们的本地仓库添加了一个远程仓库地址，pull代码时会报refusing to merge unrelated histories的错。解决方法是加一个参数--allow-unrelated-histories。 假如我们的分支是master 1git pull origin master --allow-unrelated-histories 最后更新： 2018-11-18 17:59:06","link":"/2018-03-31-git/"},{"title":"Rust更换国内源","text":"今天学cargo这节，cargo build时安装外部依赖真的慢啊。果断找国内源,果断又是ustc(中科大, emmm以前应该努力一点考中科大(￣▽￣)*) 教程开始： 设置两个环境变量 12export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-staticexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 或者直接写入~/.bashrc 使用ustcu的源下载安装rust 1curl -sSf https://mirrors.ustc.edu.cn/rust-static/rustup.sh | sh 编辑~/.cargo/config写入 1234567[registry]index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;replace-with = &apos;ustc&apos;[source.ustc]registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot; 现在cargo安装外部依赖是不是贼溜~😉","link":"/2018-01-24-change-rust-mirrors/"},{"title":"使用PHP写Git的自动部署webhook脚本","text":"现在开发项目大多使用git作为版本控制器，而且现在大多数的代码托管平台都支持自定义webhook脚本。正好利用这个脚本，结合git的workflow，我们可以轻松的做到项目代码的自动发布部署。 最简单的流程比如你的项目有两个分支，一个是代码已经经过测试可用于部署到服务器的master分支，一个用于开发的dev分支。那么我们上线的过程就是merge dev的代码到master分支。那么我们可以设置一个代码push触发的webhook。这个webhook脚本的代码也非常简单，就是git pull origin master。 最简单的实现 编写webhook.php 12345678910111213141516171819202122232425262728293031323334&lt;?php// todo 在此可以写校验权限密码之类的代码$path = dirname(__DIR__);$log_file = $path.'/runtime/logs/webhook-pull-error-output.log'; //错误日志文件的路径$descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), // 标准输入，子进程从此管道中读取数据 1 =&gt; array(\"pipe\", \"w\"), // 标准输出，子进程向此管道中写入数据 2 =&gt; array(\"file\", $log_file, \"a\") // 标准错误，写入到一个文件);$cwd = $path;$env = array('PATH' =&gt; $_SERVER['PATH']);$process = proc_open('sudo git pull origin master', $descriptorspec, $pipes, $cwd, $env);echo '&lt;pre&gt;';if (is_resource($process)) { // $pipes 现在看起来是这样的： // 0 =&gt; 可以向子进程标准输入写入的句柄 // 1 =&gt; 可以从子进程标准输出读取的句柄 // 错误输出将被追加到文件 /tmp/error-output.txt echo stream_get_contents($pipes[1]); fclose($pipes[1]); // 切记：在调用 proc_close 之前关闭所有的管道以避免死锁。 $return_value = proc_close($process); echo PHP_EOL.\"command returned $return_value\\n\";} 添加php脚本的执行用户sudoers中 比如你使用nginx+php-fpm的服务器架构，你的php-fpm的用户是www-data 12345visudo--------------------------------...#Defaults !visiblepw #注释掉这句 这句是限制sudo只能在命令行执行的www-data ALL=(ALL:ALL) NOPASSWD: /usr/bin/git push代码到master分支测试下吧~ 登陆服务器看看代码是不是已经同步好了","link":"/2018-05-01-git-webhook/"},{"title":"Composer官方镜像太慢或者被墙无法使用时的几种解决方案","text":"Composer官方镜像太慢或者被墙无法使用时的几种解决方案 使用代理被墙使用国外代理上网，总是一种行之有效的方法。加入你使用shadowsocks代理，开启之后默认的本地端口是1080。只要设置两个环境变量http_proxy和https_proxy就可以使用了。 Mac OS / Linux 终端 12export http_proxy=127.0.0.1:1080export https_proxy=127.0.0.1:1080 windows cmd命令行 12set http_proxy=127.0.0.1:1080set https_proxy=127.0.0.1:1080 这样就可以了，愉快的下载各种包吧~ 使用国内镜像地址 cnpkg提供的镜像地址： https://php.cnpkg.org LaravelChina社区提供的镜像地址： https://packagist.laravel-china.org Composer中文网提供的镜像地址： https://packagist.phpcomposer.com 镜像使用方法: 全局配置（推荐）: 1composer config -g repo.packagist composer https://php.cnpkg.org 单独项目使用： 1composer config repo.packagist composer https://php.cnpkg.org 取消镜像： 1composer config -g --unset repos.packagist —- 最后更新时间： 2019-03-18 15:09:53","link":"/2018-08-22-composer-mirrors/"},{"title":"使用Bing搜索引擎做站内搜索","text":"因为自己的博客百度未收录╮(╯-╰)╭，本来之前用的谷歌，但是谷歌毕竟翻墙才能用。决定还是换微软的Bing搜索引擎来做站内搜索吧。 大概是这样的效果 观察了下，Bing指定站点搜索很简单，比如搜索框输入关键字git site:www.ioio.pw提交之后的url是https://bing.com/search?q=git+site%3Awww.ioio.pw 所以开始写个简单的form表单就好了，代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;bing search&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Bing Search&lt;/h1&gt; &lt;form action=\"https://bing.com/search\" id=\"searchForm\"&gt; &lt;input type=\"text\" name=\"q\" value=\"\" required&gt; &lt;input type=\"hidden\" name=\"site\" value=\"www.ioio.pw\"&gt; &lt;input type=\"submit\" value=\"Search\"&gt; &lt;/form&gt;&lt;script&gt; var searchForm = document.getElementById('searchForm'); searchForm.onsubmit = function(){ var url = this.action; var q = this.children['q'].value; var site = this.children['site'].value; var url = url + '?q='+q+' site:'+ site; window.open(url); return false; };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 好了，搞定~","link":"/2018-09-16-bing-site-search/"},{"title":"盗将行(转)","text":"野史记载:宋徽宗二十年（1120年），朝野动荡，边疆不稳。时有盗者，取官济民，凡京中贪官，无一幸免，民咸敬之，却无人知其真面目。然自徽宗二十三年，此盗未曾出现，至徽宗二十六年，此盗入南京王府，未取它物，仅盗走一玉簪，自此匿迹…… 野史记载:宋钦宗元年（1126年），金军将领完颜克图率军攻陷宋都汴梁，钦宗被俘，民不聊生。1127年，宋高宗赵构建立南宋政权，时宋军与金军交战，一小卒一箭射杀完颜克图，而后屡立战功，官至护国将军，班师回朝后，宋主欲对其大行封赏，然其自辞官职，自此匿迹…… 公元1137年，一笑轩内，座无虚席，席前坐一中年男子，相貌非凡，文墨中颇有武将风采，有听者席下暗叹:此等人间琢玉郎，天应乞与点酥娘，奈何天公不作美啊……，只见男子手执醒木一敲，“今日我给诸位讲讲那位消失大盗的故事。诸位都知道这大盗在十多年前劫富济贫，百姓视之为神明，诸位可知为何这大盗消失几年后，又于南京王府盗取一支玉簪此后便再无消息……” “没错，我就是说书人，也是大盗，亦是护国将军，二十岁之前，我从师傅那里习得武艺，学成后因喜自在生活，却看不惯贪官污吏，由此开始了劫贪济贫的生活，本以为自己一生都会这样一个人渡过，清风明月、落日余霞，却不曾想她走进了我的生活，那日，在盗取康王府珍宝夜明珠后，为躲避追捕，我纵马逃出城外，却因勒马不及，无意中轻微带起路边一女子的裙边，看官兵并未追来，我下马向女子道歉，却不想只此一眼，便是一生，自认这世间没有盗不到的东西的我，却开始担心盗不到她的心，然而自己的心却已被她带走，因为这一眼，我忽然想不再为盗，娶其为妻。老天待我不薄，我盗得了她的心，然后我渡过了此生最快乐的三年，我陪她吃巷子里的那家汤面、谈笑中窗外白雪纷飞，不惜用夜明珠做弹珠弹山雀……公元1126年，我决定娶她，听闻南京王府中有一玉簪，得之赠予心爱之人，可与其生生世世永不分离，我决定将它偷来送给她，和她说好过些日子我就会回来迎娶她，之后就踏上了去南京的路，在我盗得玉簪返途中，听闻金军攻陷汴梁，一路烧杀抢掠，民不聊生，我慌张的回到汴梁，路上不停的安慰自己她一定没事，却不得不接受她已过世的现实，可能贼就是贼吧，不论我是否劫富济贫，报应终究还是来了，我失去了最心爱的人，自此我弃盗从军，带着对她的留恋，将一腔恨意全部放在了金军身上，将士们都说我在战场勇猛异常，却不知我心中满是为她报仇的怒意与没有留在她身边的悔意。最终金军败退，我射杀了完颜克图，也因此被封为护国大将军，朝堂之上，我推却了赏赐，辞掉了官职，来到了那个有着她爱吃的汤面的巷子，开了这一笑轩，成为了一个讲尽故事，却走不出自己故事的说书人。” “……在大将军辞官之后，便无人知晓其去处，徒留这么一个故事，我偶然闻得，讲与诸位听。今日就讲到这里，多谢诸位捧场。”一声醒木，众人还未从大盗的故事中回过神来，却发现说书人已然转进后堂，众人起身四散，说书人转进后堂已是泪流满面，看着后堂院中的枇杷树，树上挂着那只未送出的玉簪…… 作者：一个人的兵荒馬乱链接：https://www.jianshu.com/p/7aa6bfbb0df1來源：简书","link":"/2018-09-18-%E7%9B%97%E5%B0%86%E8%A1%8C/"},{"title":"Docker容器动态添加端口","text":"突然遇到一个问题怎么给一个已经在运行的docker容器添加端口，找了找资料，记个笔记。 参考： 怎么给运行中的docker容器添加新的端口 修改docker容器端口映射的方法 iptable规则查看，添加，删除和修改 方法1 修改iptables端口映射 docker的端口映射并不是在docker技术中实现的，而是通过宿主机的iptables来实现。通过控制网桥来做端口映射，类似路由器中设置路由端口映射。 比如我们有一个容器的80端口映射到主机的8080端口，先查看iptables到底设置了什么规则： 1sudo iptables -t nat -vnL 在结果中有一条： 1234Chain DOCKERtarget prot opt source destinationRETURN all -- 0.0.0.0/0 0.0.0.0/0DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:8080 to:172.17.0.3:80 我们可以看到docker创建了一个名为DOKCER的自定义的链条Chain。而我开放80端口的容器的ip是172.17.0.3 也可以通过inspect命令查看容器ip 1docker inspect containerId |grep IPAddress 我们想再增加一个端口映射，比如8081-&gt;81，就在这个链条是再加一条规则： 1sudo iptables -t nat -A DOCKER -p tcp --dport 8081 -j DNAT --to-destination 172.17.0.3:81 如果加错了或者想修改： 先显示行号查看 1sudo iptables -t nat -vnL DOCKER --line-number 删除规则3 1sudo iptables -t nat -D DOCKER 3 方法2 修改容器配置文件容器的配置文件/var/lib/docker/containers/[containerId]目录下，hostconfig.json和config.v2.json修改好之后，重启容器服务。 方法3 把运行中的容器生成新的镜像，然后运行新的镜像 提交一个运行中的容器为镜像 1docker commit containerid heropoo/example 运行heropoo/example镜像并添加8080映射容器80端口 1docker run -d -p 8000:80 heropoo/example /bin/sh 试试吧~😎","link":"/2018-09-16-docker-container-port/"},{"title":"关于Yii2查询数据对象ActiveRecord的json序列化问题","text":"今天在使用json_encode函数序列化Yii2查询得到的数据模型对象（通常继承ActiveRecord类）时，发现返回结果是{},而不是预期的数据库字段键值对这种形式：{&quot;name&quot;： &quot;xxx&quot;, &quot;sex&quot;: 1} 后来赶时间就直接在手动处理了下，改动了下模型对象让它接入JsonSerializable接口，并实现其接口方法，类似这样； 12345678910//...class User extends ActiveRecord implements \\JsonSerializable{ //... 其他代码 public function jsonSerialize (){ return $this-&gt;toArray(); }} 然后完美的解决了。 但是后来代码写完了，觉得这个框架应该提供了这个问题的解决方法了吧。然后找了找，果然有的： \\yii\\helpers\\BaseJson::encode($user)。然后翻了翻源代码，部分代码是这样的： 12345678910111213141516171819202122232425//from \\yii\\helpers\\BaseJson::processDataif (is_object($data)) { if ($data instanceof JsExpression) { $token = \"!{[$expPrefix=\" . count($expressions) . ']}!'; $expressions['\"' . $token . '\"'] = $data-&gt;expression; return $token; } elseif ($data instanceof \\JsonSerializable) { $data = $data-&gt;jsonSerialize(); } elseif ($data instanceof Arrayable) { // &lt;---here $data = $data-&gt;toArray(); } elseif ($data instanceof \\SimpleXMLElement) { $data = (array) $data; } else { $result = []; foreach ($data as $name =&gt; $value) { $result[$name] = $value; } $data = $result; } if ($data === []) { return new \\stdClass(); }} 作者在处理数据的时候做了判断，ActiveRecord类接了Arrayable接口，然后作者也是使用toArray()方法。然后我觉得放心了。我的改造也没有错。当然了使用框架提供的方法更简单点。","link":"/2018-10-16-yii2-activerecord-to-json/"},{"title":"安装Jupyter笔记本","text":"安装Jupyter笔记本，做个笔记 通过pip安装 1sudo pip3 install jupyter 创建Jupyter默认配置文件 1jupyter notebook --generate-config 生成SHA1加密的密钥，如’sha1:XXXXXX’ 1234ipython--------------------------------------from notebook.auth import passwdpasswd() 修改配置文件 123vim .jupyter/jupyter_notebook_config.py--------------------------------------c.NotebookApp.password = u'sha1:XXXXXX' 运行jupyter 1jupyter notebook 可选的运行参数 1jupyter notebook --ip=0.0.0.0 --no-browser --allow-root 打开浏览器输入 http://localhost:8888","link":"/2018-11-02-jupyter/"},{"title":"修复gitment评论","text":"最近几个月博客外挂的gitment评论老是挂，也一直没时间修复。这几天想办法修好了。就说说修复的过程吧。 从我开始用gitment的评论系统，总共出现过两次问题： 1. github-issue label的字符长度限制这次导致原本默认使用网页url地址做label初始化评论的方式无法使用，url太长了超过了50个字符。而之前已经初始化好的评论（issue）不收影响。所以后来我想了个办法来改，就是用时间来初始化，并且对于为了兼容之前的评论，加了时间判断： 123456789101112131415var page_date = '{{ page.date }}';var id = window.location.href;if(page_date &gt; '2018-04-31 00:00:00 +0000'){ id = page_date;}var gitment = new Gitment({ id: id, // 可选。默认为 location.href owner: 'heropoo', repo: 'heropoo.github.io', oauth: { client_id: 'cccc', client_secret: 'xxxx', },});gitment.render('container'); 2. gitment 作者提供的oauth授权服务不可用这次好像挂了使用作者提供的js的博客全挂了😂。 解决办法就是自己搭建或者使用别人搭建的oauth授权服务了。 好吧，换个授权服务总算好了。 3. 升级https现在github-page提供强制https。升级之后发现之前兼容的使用页面url初始化的评论又不能用了。 ㄟ( ▔, ▔ )ㄏ但是还得修嘛。后来仔细观察了下，原来作者是使用gitment和页面js中获取的id来匹配出一个issue的。所以只要去github修改issue label就可以了。把原来很长的url label改成现在的短的，比如像我一样用时间。然后页面上的兼容的js也去掉就搞定了。 123456789101112131415var page_date = '{{ page.date }}';//var id = window.location.href;//if(page_date &gt; '2018-04-31 00:00:00 +0000'){var id = page_date;//}var gitment = new Gitment({ id: id, // 可选。默认为 location.href owner: 'heropoo', repo: 'heropoo.github.io', oauth: { client_id: 'cccc', client_secret: 'xxxx', },});gitment.render('container'); 好了，搞完收工。","link":"/2018-10-27-fix-gitment/"},{"title":"从SSH私钥中重新生成公钥","text":"从SSH私钥中重新生成公钥 假如我们的私钥是id_rsa 12ssh-keygen -y -f id_rsassh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDdqNYfRhP/4Y1Kwr5/ZfRPbQkDEKQ9sLpGYex2bzXsPIXZmpgI4yUkLkQRCyvrMoZQKOcabb+GgnrYJvPR1rO/CVI9bfUw+MD1OFvnJUI2deATTeMj2hlY/IDSS1q3AG1ZEztFLizTiJqZvkjx/WPXR/b7ZIVV5DRIeaUMCfEjNIRD+spcJ5ALBuwGPO+4irAXIxgTxbYMDD2ASnpr6v7oSzc0N5ZhZ7rV1dk6hA/RowqYO7DwIvZtOAc55sv6pSUYG3RUJhnkzcmE5VTbyTMKB6O738np6DEw5soWdL1ITPgLE+uJcTt8tcOmPkBXv+45A4TuJ5ksONil8xhfVYG3 可以直接重定向到文件 1ssh-keygen -y -f id_rsa &gt; id_rsa.pub","link":"/2018-11-19-get-ssh-public-key-from-private-key/"},{"title":"MySQL5.7的JSON基本操作","text":"MySQL从5.7版本开始就支持JSON格式的数据，操作用起来挺方便的。 建表在新建表时字段类型可以直接设置为json类型，比如我们创建一张表： 1mysql&gt; CREATE TABLE `test_user`(`id` INT PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(50) NOT NULL, `info` JSON); json类型字段可以为NULL 插入数据：1mysql&gt; INSERT INTO test_user(`name`, `info`) VALUES(&apos;xiaoming&apos;,&apos;{&quot;sex&quot;: 1, &quot;age&quot;: 18, &quot;nick_name&quot;: &quot;小萌&quot;}&apos;); json类型的字段必须时一个有效的json字符串 可以使用JSON_OBJECT()函数构造json对象： 1mysql&gt; INSERT INTO test_user(`name`, `info`) VALUES(&apos;xiaohua&apos;, JSON_OBJECT(&quot;sex&quot;, 0, &quot;age&quot;, 17)); 使用JSON_ARRAY()函数构造json数组： 1mysql&gt; INSERT INTO test_user(`name`, `info`) VALUES(&apos;xiaozhang&apos;, JSON_OBJECT(&quot;sex&quot;, 1, &quot;age&quot;, 19, &quot;tag&quot;, JSON_ARRAY(3,5,90))); 现在查看test_user表中的数据： 123456789mysql&gt; select * from test_user;+----+-----------+--------------------------------------------+| id | name | info |+----+-----------+--------------------------------------------+| 1 | xiaoming | {&quot;age&quot;: 18, &quot;sex&quot;: 1, &quot;nick_name&quot;: &quot;小萌&quot;} || 2 | xiaohua | {&quot;age&quot;: 17, &quot;sex&quot;: 0} || 3 | xiaozhang | {&quot;age&quot;: 19, &quot;sex&quot;: 1, &quot;tag&quot;: [3, 5, 90]} |+----+-----------+--------------------------------------------+3 rows in set (0.04 sec) 查询表达式： 对象为json列-&gt;'$.键', 数组为json列-&gt;'$.键[index]' 123456789mysql&gt; select name, info-&gt;&apos;$.nick_name&apos;, info-&gt;&apos;$.sex&apos;, info-&gt;&apos;$.tag[0]&apos; from test_user;+-----------+---------------------+---------------+------------------+| name | info-&gt;&apos;$.nick_name&apos; | info-&gt;&apos;$.sex&apos; | info-&gt;&apos;$.tag[0]&apos; |+-----------+---------------------+---------------+------------------+| xiaoming | &quot;小萌&quot; | 1 | NULL || xiaohua | NULL | 0 | NULL || xiaozhang | NULL | 1 | 3 |+-----------+---------------------+---------------+------------------+3 rows in set (0.04 sec) 等价于：对象为JSON_EXTRACT(json列 , '$.键')，数组为JSON_EXTRACT(json列 , '$.键[index]') 123456789mysql&gt; select name, JSON_EXTRACT(info, &apos;$.nick_name&apos;), JSON_EXTRACT(info, &apos;$.sex&apos;), JSON_EXTRACT(info, &apos;$.tag[0]&apos;) from test_user;+-----------+-----------------------------------+-----------------------------+--------------------------------+| name | JSON_EXTRACT(info, &apos;$.nick_name&apos;) | JSON_EXTRACT(info, &apos;$.sex&apos;) | JSON_EXTRACT(info, &apos;$.tag[0]&apos;) |+-----------+-----------------------------------+-----------------------------+--------------------------------+| xiaoming | &quot;小萌&quot; | 1 | NULL || xiaohua | NULL | 0 | NULL || xiaozhang | NULL | 1 | 3 |+-----------+-----------------------------------+-----------------------------+--------------------------------+3 rows in set (0.04 sec) 不过看到上面&quot;小萌&quot;是带双引号的，这不是我们想要的，可以用JSON_UNQUOTE函数将双引号去掉 1234567mysql&gt; select name, JSON_UNQUOTE(info-&gt;&apos;$.nick_name&apos;) from test_user where name=&apos;xiaoming&apos;;+----------+-----------------------------------+| name | JSON_UNQUOTE(info-&gt;&apos;$.nick_name&apos;) |+----------+-----------------------------------+| xiaoming | 小萌 |+----------+-----------------------------------+1 row in set (0.05 sec) 也可以直接使用操作符-&gt;&gt; 1234567mysql&gt; select name, info-&gt;&gt;&apos;$.nick_name&apos; from test_user where name=&apos;xiaoming&apos;;+----------+----------------------+| name | info-&gt;&gt;&apos;$.nick_name&apos; |+----------+----------------------+| xiaoming | 小萌 |+----------+----------------------+1 row in set (0.06 sec) 当然属性也可以作为查询条件 1234567mysql&gt; select name, info-&gt;&gt;&apos;$.nick_name&apos; from test_user where info-&gt;&apos;$.nick_name&apos;=&apos;小萌&apos;;+----------+----------------------+| name | info-&gt;&gt;&apos;$.nick_name&apos; |+----------+----------------------+| xiaoming | 小萌 |+----------+----------------------+1 row in set (0.05 sec) 值得一提的是，可以通过虚拟列对JSON类型的指定属性进行快速查询。 创建虚拟列: 1mysql&gt; ALTER TABLE `test_user` ADD `nick_name` VARCHAR(50) GENERATED ALWAYS AS (info-&gt;&gt;&apos;$.nick_name&apos;) VIRTUAL; 注意用操作符-&gt;&gt; 使用时和普通类型的列查询是一样: 1234567mysql&gt; select name,nick_name from test_user where nick_name=&apos;小萌&apos;;+----------+-----------+| name | nick_name |+----------+-----------+| xiaoming | 小萌 |+----------+-----------+1 row in set (0.05 sec) 更新使用JSON_INSERT()插入新值，但不会覆盖已经存在的值 1mysql&gt; UPDATE test_user SET info = JSON_INSERT(info, &apos;$.sex&apos;, 1, &apos;$.nick_name&apos;, &apos;小花&apos;) where id=2; 看下结果 1234567mysql&gt; select * from test_user where id=2;+----+---------+--------------------------------------------+-----------+| id | name | info | nick_name |+----+---------+--------------------------------------------+-----------+| 2 | xiaohua | {&quot;age&quot;: 17, &quot;sex&quot;: 0, &quot;nick_name&quot;: &quot;小花&quot;} | 小花 |+----+---------+--------------------------------------------+-----------+1 row in set (0.06 sec) 使用JSON_SET()插入新值，并覆盖已经存在的值 1mysql&gt; UPDATE test_user SET info = JSON_SET(info, &apos;$.sex&apos;, 0, &apos;$.nick_name&apos;, &apos;小张&apos;) where id=3; 看下结果 1234567mysql&gt; select * from test_user where id=3;+----+-----------+---------------------------------------------------------------+-----------+| id | name | info | nick_name |+----+-----------+---------------------------------------------------------------+-----------+| 3 | xiaozhang | {&quot;age&quot;: 19, &quot;sex&quot;: 1, &quot;tag&quot;: [3, 5, 90], &quot;nick_name&quot;: &quot;小张&quot;} | 小张 |+----+-----------+---------------------------------------------------------------+-----------+1 row in set (0.06 sec) 使用JSON_REPLACE()只替换存在的值 1mysql&gt; UPDATE test_user SET info = JSON_REPLACE(info, &apos;$.sex&apos;, 1, &apos;$.tag&apos;, &apos;[1,2,3]&apos;) where id=2; 看下结果 1234567mysql&gt; select * from test_user where id=2;+----+---------+--------------------------------------------+-----------+| id | name | info | nick_name |+----+---------+--------------------------------------------+-----------+| 2 | xiaohua | {&quot;age&quot;: 17, &quot;sex&quot;: 1, &quot;nick_name&quot;: &quot;小花&quot;} | 小花 |+----+---------+--------------------------------------------+-----------+1 row in set (0.06 sec) 可以看到tag没有更新进去 删除使用JSON_REMOVE()删除JSON元素 1mysql&gt; UPDATE test_user SET info = JSON_REMOVE(info, &apos;$.sex&apos;, &apos;$.tag&apos;) where id=1; 看下结果 1234567mysql&gt; select * from test_user where id=1;+----+----------+----------------------------------+-----------+| id | name | info | nick_name |+----+----------+----------------------------------+-----------+| 1 | xiaoming | {&quot;age&quot;: 18, &quot;nick_name&quot;: &quot;小萌&quot;} | 小萌 |+----+----------+----------------------------------+-----------+1 row in set (0.05 sec) 最后从MySQL的官方网站查看帮助文档：http://dev.mysql.com/doc/refman/5.7/en/json.html 😎","link":"/2018-11-18-mysql-json/"},{"title":"关于PHP Composer 版本号前置~与^符号的区别(转)","text":"~和^的意思很接近，在x.y的情况下是一样的，都是代表x.y &lt;= 版本号 &lt; (x+1).0。但是在版本号是x.y.z的情况下有区别，举个例子： ~1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 1.3.0 ^1.2.3 代表 1.2.3 &lt;= 版本号 &lt; 2.0.0 原文链接： https://www.cnblogs.com/hcpzhe/p/7909651.html","link":"/2018-12-29-php-composer-version/"},{"title":"PHP多进程之pcntl扩展的使用","text":"PHP实现多进程的模块是pcntl，而且只有在linux下才使用这个拓展，不过现在服务器都基本使用linux，我们还是可以用起来的。 安装可以直接使用pecl install pcntl，或者去https://pecl.php.net/下载源码包手动编译安装。 使用先举个官方的栗子： 12345678910111213&lt;?php$pid = pcntl_fork();//父进程和子进程都会执行下面代码if ($pid == -1) { //错误处理：创建子进程失败时返回-1. die('could not fork');} else if ($pid) { //父进程会得到子进程号，所以这里是父进程执行的逻辑 pcntl_wait($status); //等待子进程中断，防止子进程成为僵尸进程。} else { //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。} 使用到的函数: pcntl_fork在当前进程当前位置产生分支（子进程）。fork是创建了一个子进程，父进程和子进程 都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程 号，而子进程得到的是0。 pcntl_wait 等待或返回fork的子进程状态。这个函数会挂起当前进程的执行直到一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。如果一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将被释放。 再来个经典栗子： 12345678910111213141516171819202122232425262728293031&lt;?php$children = []; //定义一个数组用来存储子进程的pid$m = 10; //fork 10次for ($x = 0; $x &lt; $m; $x++) { $pid = pcntl_fork(); if ($pid == -1) { die('could not fork '.$x); } else if ($pid) { //父进程执行的代码块 $children[] = $pid; printf(\"Parent get child %d 's pid: %d\\n\", $x, $pid); } else { //子进程执行的代码块 $my_pid = posix_getpid(); //子进程获取自己的pid //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。 echo \"Child $my_pid running...\\n\"; sleep(10); //子进程干点啥 这里是睡10秒 echo \"...Child $my_pid done\\n\"; exit(0); //子进程执行结束exit }}while(count($children) &gt; 0) { foreach($children as $key =&gt; $pid) { $res = pcntl_waitpid($pid, $status, WNOHANG); //获取返回指定pid的返回状态加了第二个参数非阻塞 if($res == -1 || $res &gt; 0){ echo \"Parent get child $pid 's status: $status\\n\"; unset($children[$key]); } } sleep(1); //每一秒去轮询没有退出的子进程状态} —- 最后更新于 2019-03-27 19:04:55","link":"/2019-01-02-php-pcntl/"},{"title":"容器的宠儿AlpineLinux的基本使用","text":"现在docker的容器技术很流行，对于我们这种整天被各种万恶的开发环境坑的开发来说是个解放。但是当我们在拉取docker镜像的时候，会发现普遍基于debian或者ubuntu的镜像都是体积很大，动辄几十或者上百兆。当然了docker镜像在构建的时候会删除旭东无用的东西并且使用精简系统模板。尽管这样做还是很大，起码也得有个几十兆吧。所以使用一个本身体积就小的操作系统做基础模板来构建才是关键。AlpineLinux是一个使用busybox的linux操作系统，而他的体积只需要4兆多。所以对我这种喜欢轻量级的人还说，这真是好东西啊！ 哈哈~废话不多说了，说说这个系统的基本使用吧 软件包管理更新软件包索引文件 1apk update 如果感觉网速很慢，那可以先换个中国的源 12#中科大的源 速度杠杠的sed -i &apos;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&apos; /etc/apk/repositories 下面我们以安装nginx为例 安装软件包 1apk add nginx 安装软件包到最新 1apk add --update nginx 查找软件包 1apk search nginx 卸载软件包 1apk del nginx 服务管理启动Nginx 1/etc/init.d/nginx start 添加nginx到启动服务中，下次开机自动运行 1rc-update add nginx 把nginx从启动服务中移除，下次开机不会自动运行 1rc-update del nginx 一些网络工具所在软件包telnet =&gt; busybox-extras","link":"/2019-01-17-alpinelinux/"},{"title":"用Redis实现PHP异步队列","text":"最近项目中用到好多用异步队列处理的后台任务，有些心得，记录一下。 下面引用百度百科的对队列的解释： 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。简单点讲就是：先进先出 要实现一个队列，你可以根据自身服务器资源，可选数据库或者redis或者其他更高级的队列资源来实现。 简单实现，大概代码是这样子的： 12345678910111213141516171819202122class Queue{ protected $items = []; /** * 从队列尾部插入数据 * @param string $key 对列名称 */ public function push($key, $value){ isset($this-&gt;items[$key]) or $this-&gt;items[$key] = []; return array_push($this-&gt;items[$key], $value); } /** * 从队列头部取出数据 * @param string $key 对列名称 * return mixed $value 数据 */ public function pop($key){ isset($this-&gt;items[$key]) or $this-&gt;items[$key] = []; return array_shift($this-&gt;items[$key]); }} 测试： 12345678910$queue = new Queue();var_dump($queue-&gt;pop('list_1')); //输出 NULL$queue-&gt;push('list_1', '1');$queue-&gt;push('list_1', '2');$queue-&gt;push('list_1', '3');var_dump($queue-&gt;pop('list_1')); //输出 string(1) \"1\"var_dump($queue-&gt;pop('list_1')); //输出 string(1) \"2\" 上面是一个直接存储在数组中的队列，只能在一个php生命周期中使用。我们可以把存储的方式改成别的，例如数据库或者redis什么的。 这里我们使用redis，用到redis的有序列表（list） 123456789101112131415161718192021222324class RedisQueue{ protected $client; //这里使用了predis这个库连接redis public function __construct(\\Predis\\Client $client) { $this-&gt;client = $client; } /** * 从队列尾部插入数据 * @param string $key 对列名称 */ public function push($key, $value){ return $this-&gt;client-&gt;rpush($key, $value); //从右边入队 } /** * 从队列头部取出数据 * @param string $key 对列名称 * @return mixed $value 数据 */ public function pop($key){ return $this-&gt;client-&gt;lpop($key); //从左边取 }} 你还是可以使用上面的例子测试下。 当然了，还有很多情况下，我们的队列要延时出队，我们就要使用redis的另外两种数据类型：有序集合zset和哈希hlist 最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class RedisQueue{ protected $client; public function __construct(\\Predis\\Client $client) { $this-&gt;client = $client; } /** * 从队列尾部插入数据 * @param string $key 对列名称 * @param int $delay 延迟多少秒 * @return mixed $value 数据 */ public function push($key, $value, $delay = null){ if(is_null($delay)){ //不使用延迟的时候还是使用以前的rpush入队 return $this-&gt;client-&gt;rpush($key, $value); } $time = time() + $delay; if($time &gt; time()){ //还未到该入队的时间时 $hash_key = md5($this-&gt;randString(16).'_'.time().'_'.$value); //生成一个唯一key return $this-&gt;client-&gt;transaction(function($tx) use ($key, $time, $hash_key, $value){ //使用reids事务 /** @var \\Predis\\Client $tx */ $tx-&gt;zadd($key.':zset', [ $hash_key=&gt;$time //这里以生成的唯一key做 对象member 以time做分数score ]); $tx-&gt;hset($key.':hlist', $hash_key, $value); //并且保存唯一key和值的映射 $tx-&gt;expire($key.':zset', 7*86400); //有效期7天 $tx-&gt;expire($key.':hlist', 7*86400); }); } } /** * 取出数据 * @param string $key 对列名称 */ public function receive($key){ if($this-&gt;getLock($key.':lock')){ //使用锁保证线程安全 $keys = $this-&gt;client-&gt;zrangebyscore($key.':zset',0, time()); //按当前时间取分数小于等于当前时间的集合元素 if(!empty($keys)) { $message_datas = $this-&gt;client-&gt;hmget($key.':hlist', $keys); //通过这些key拿到值 $this-&gt;client-&gt;transaction(function($tx) use ($key, $keys, $message_datas){ //继续使用redis事务保证数据完整 /** @var \\Predis\\Client $tx */ foreach ($message_datas as $i =&gt; $message_data){ $tx-&gt;rpush($key, $message_data); //这时候才是真正的入队 $hash_key = $keys[$i]; $tx-&gt;hdel($key.':hlist', $hash_key); //从hash列表删除元素 $tx-&gt;zrem($key.':zset', $hash_key); //从集合删除元素 } }); } $this-&gt;releaseLock($key.':lock');//释放锁 } return $this-&gt;client-&gt;lpop($key); //出队 } public function getLock($key){ $ret = true; if($this-&gt;client-&gt;incr($key) != 1){ $ret = false; } $ttl = $this-&gt;client-&gt;ttl($key); if($ttl == -1) { //forever $this-&gt;client-&gt;expire($key, 60); } return $ret; } public function releaseLock($key){ $this-&gt;client-&gt;del($key); } protected function randString($length){ $str = ''; $strPol = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\"; $max = strlen($strPol) - 1; for ($i = 0; $i &lt; $length; $i++) { $str .= $strPol[mt_rand(0, $max)]; } return $str; }} 主要看上面入队（push）和出队（receive）方法，我代码写了详细的注释。","link":"/2019-03-29-php-queue/"},{"title":"玩转ElasticSearch全文搜索","text":"玩转ElasticSearch全文搜索，做个笔记。 运行ElasticSearch服务为了省去繁杂的安装，跳过万恶的环境，我们使用Docker容器来跑ElasticSearch的服务。 我们使用官方的elasticsearch:5.6.16-alpine作为基础镜像，另外添加一个中文分词插件elasticsearch-ik 我们的Dockerfile内容如下，很简单，只需两行哟： 12FROM elasticsearch:5.6.16-alpineRUN elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.16/elasticsearch-analysis-ik-5.6.16.zip 构建镜像： 1docker build -t heropoo/elasticsearch-ik . 运行容器： 1docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; heropoo/elasticsearch-ik 因为ElasticSearch提供了REST API，我们直接可以用浏览器访问 http://localhost:9200 看看服务是否正常。 基本概念Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 IndexElastic 会索引所有字段，经过处理后写入一个反向索引。查找数据的时候，直接查找该索引。所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。 查看当前节点的所有 Index 1curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos; DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。例如： 12345{ &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;} 同一个 Index 里面的 Document，不要求有相同的字段结构，但是最好保持相同，这样有利于提高搜索效率。 Type不同的 Type 应该有相似的字段结构，举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。 下面的命令可以列出每个 Index 所包含的 Type 1curl &apos;localhost:9200/_mapping?pretty=true&apos; pretty参数是优化显示结果易于查看 Index操作查看当前节点的所有 Index1curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos; 新建Index1curl -X PUT &apos;http://localhost:9200/weather&apos; 删除Index1curl -X DELETE &apos;http://localhost:9200/weather&apos; 新建一个 Index，指定需要分词的字段123456789101112131415161718192021222324curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;{ &quot;mappings&quot;: { &quot;person&quot;: { &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;title&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;desc&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; } } } }}&apos; 上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段 user、title、desc 这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。 数据操作新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录 123456curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;{ &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;}&apos; 新增记录的时候，也可以不指定 Id，这时要改成 POST 请求 123456curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;{ &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;软件工程师&quot;}&apos; 其实PUT就是存在时修改，不存在时创建。 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录 1curl &apos;localhost:9200/accounts/person/1?pretty=true&apos; 删除记录1curl -X DELETE &apos;localhost:9200/accounts/person/1&apos; 更新记录参考上面创建操作，用PUT方法 123456curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;{ &quot;user&quot;: &quot;张三1&quot;, &quot;title&quot;: &quot;工程师1&quot;, &quot;desc&quot;: &quot;数据库管理1&quot;}&apos; 数据查询返回所有记录1curl &apos;localhost:9200/accounts/person/_search&apos; 全文搜索1234curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;数据库&quot; }}}&apos; 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系 1234curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件 系统&quot; }}}&apos; 如果要执行多个关键词的and搜索，必须使用布尔查询 1234567891011curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;desc&quot;: &quot;软件&quot; } }, { &quot;match&quot;: { &quot;desc&quot;: &quot;系统&quot; } } ] } }}&apos; 搞定~ 参考：http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html","link":"/2019-04-09-elasticsearch/"},{"title":"常用nginx web配置","text":"常用nginx对于web项目配置整理，做个笔记。 php web项目配置1234567891011121314151617181920212223242526272829303132333435363738server { listen 80; listen [::]:80; # 设置上传最大为5MB client_max_body_size 5m; root /srv/www/wechat/public; index index.html index.php; server_name example.com; location / { try_files $uri $uri/ =404; } # 支持php location ~ \\.php$ { # Check that the PHP script exists before passing it try_files $fastcgi_script_name =404; fastcgi_index index.php; include fastcgi.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # location ~ /\\.ht { deny all; }} php web项目配置 支持laravel、symfony、Yii2单入口12345678... location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. #try_files $uri $uri/ =404; # 注释上面这句，使用下面这句 try_files $uri $uri/ /index.php?$query_string; }... php web项目配置 支持ThinkPHP12345678910111213141516171819202122... location ~ \\.php$ { # regex to split $uri to $fastcgi_script_name and $fastcgi_path fastcgi_split_path_info ^(.+\\.php)(/.+)$; # Check that the PHP script exists before passing it try_files $fastcgi_script_name =404; # Bypass the fact that try_files resets $fastcgi_path_info # see: http://trac.nginx.org/nginx/ticket/321 set $path_info $fastcgi_path_info; fastcgi_param PATH_INFO $path_info; # ThinkPHP依赖PATH_INFO这个环境变量 fastcgi_index index.php; include fastcgi.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; }... php web项目配置 禁止访问上传目录下的php文件1234567... # 这个块location要放在 location ~ \\.php$ 之前 location ~ ^/uploads/.*\\.php$ { # 所有/uploads文件目录下的.php文件都被禁止访问 #deny all; # 返回403 return 404; #返回404 }...","link":"/2019-05-22-nginx-web-conf/"},{"title":"关于大文件上传","text":"最近在做视频上传，我们使用切片上传大文件，做个笔记。 思路 使用js读取form表单中选择的file，计算文件md5值，并上传md5值到服务端，检查文件是否已上传过（类似秒传功能） 若文件未上传过，按照其大小切成1MB大小的块，小于1MB的不用切 用ajax异步提交切好的块上传至服务端（一个块一个请求，不阻塞，多线程） 当上传完成所有切块，发起一个合并文件的请求，服务端进行前面上传的文件块的合并，合并完成即上传完成。 实现js计算文件md5使用spark-md5.js,据说这个库使用的是世界上最快的md5算法。 js对文件切片并使用ajax上传切片 12345678910111213141516171819202122232425262728//...let size = file.size; //获取文件大小const shardSize = 1024 * 1024; // 块大小1MBlet shardCount = Math.ceil(size/shardSize); //可切成的块数for(let i = 0; i &lt; shardCount; i++){ let start = i * shardSize, end = Math.min(size, start + shardSize); let form = new FormData(); form.append('file', file.slice(start, end)); //用slice方法切片 form.append('size', end - start); form.append('name', name); form.append('total', shardCount); form.append('md5', file_md5); //文件md5值 form.append('index', i); //第几块 $.ajax({ url: 'upload.php?type=shard', type: \"POST\", data: form, // async: false, //是否异步上传，默认true processData: false, //很重要，告诉jquery不要对form进行处理 contentType: false, //很重要，指定为false才能形成正确的Content-Type success: function (res) { // 成功回调 } }} php端保存切片 1234567891011121314151617$path = __DIR__ . '/uploads';$file = $_FILES['file'];$total = $_POST['total'];$index = $_POST['index'];$size = $_POST['size'];$dst_file = $path . '/' . $name . '-' . $total . ':' . $index; // 切片文件存储的文件名 if ($file[\"error\"] &gt; 0) { echo json_encode(['code'=&gt;400, 'msg'=&gt;$file[\"error\"]]);die;} else { $res = move_uploaded_file($file['tmp_name'], $dst_file); if ($res) { file_put_contents($dst_file . '.info', $size); // 切片上传成功，写一个保存其大小的文件，后续合并是校验文件用的到 echo json_encode(['code'=&gt;200, 'msg'=&gt;'shard ok']);die; } else { echo json_encode(['code'=&gt;400, 'msg'=&gt;'shard move_uploaded_file error']);die; }} php端合并 1234567891011121314151617181920212223242526272829303132//...function mergeFile($name, $total, &amp;$msg){ // 校验切片文件是否都上传完成，是否完整 for ($i = 0; $i &lt; $total; $i++) { if (!file_exists($name . '-' . $total . ':' . $i . '.info') || !file_exists($name . '-' . $total . ':' . $i)) { $msg = \"shard error $i\"; return false; } else if (filesize($name . '-' . $total . ':' . $i) != file_get_contents($name . '-' . $total . ':' . $i . '.info')) { $msg = \"shard size error $i\"; return false; } } @unlink($name); if (file_exists($name . '.lock')) { //加锁 防止有其他进程写文件，造成文件损坏 $msg = 'on lock'; return false; } touch($name . '.lock'); $file = fopen($name, 'a+'); for ($i = 0; $i &lt; $total; $i++) { //按切片顺序写入文件 $shardFile = fopen($name . '-' . $total . ':' . $i, 'r'); $shardData = fread($shardFile, filesize($name . '-' . $total . ':' . $i)); fwrite($file, $shardData); fclose($shardFile); unlink($name . '-' . $total . ':' . $i); unlink($name . '-' . $total . ':' . $i . '.info'); } fclose($file); unlink($name . '.lock'); return true;} 我也写好了一个demo，传送门 下面是这个demo的效果图： 这个demo有些方面还不够完善，后续持续完善吧～","link":"/2019-05-23-upload-large-file/"},{"title":"在网页上使用MathJax渲染LaTex格式数学公式","text":"最近在看一些机器学习算法的东西，用到好多数学公式，发现有个很强大的js库可以完美的渲染LaTex格式数学公式，值得推荐下。 使用方法：在你的html模版中引入这个js 1&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; 写几个公式测试下： 质能方程是$$E=mc^2$$ 代码： 1$$E=mc^2$$ k-means算法的代价函数:$$J(c,\\mu )=\\sum_{i=1}^{k}\\left | x^{(i)}-\\mu _{c^{(i)}} \\right |^{2}$$ 代码： 1$$J(c,\\mu )=\\sum_{i=1}^{k}\\left \\| x^{(i)}-\\mu _{c^{(i)}} \\right \\|^{2}$$ 感受效果还可以😉😛😛 再附送一个在线的公式编辑器https://www.codecogs.com/latex/eqneditor.php","link":"/2019-05-27-math-jax/"},{"title":"Linux软连接和硬链接","text":"Linux软连接和硬链接，一个经常傻傻分不清楚的概念，现在我们仔细理一理。 1.Linux链接概念Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。 【硬连接】 硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 【软连接】 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 2.通过实验加深理解12345678[root@Linux]$ touch f1 #创建一个测试文件f1[root@Linux]$ ln f1 f2 #创建f1的一个硬连接文件f2[root@Linux]$ ln -s f1 f3 #创建f1的一个符号连接文件f3[root@Linux]$ ls -li # -i参数显示文件的inode节点信息total 09797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f19797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f29797649 lrwxrwxrwx 1 root root 2 Apr 21 08:11 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件f2与原文件f1的inode节点相同，均为9797648，然而符号连接文件的inode节点不同。 123456789101112[root@Linux]$ echo \"I am f1 file\" &gt;&gt;f1[root@Linux]$ cat f1I am f1 file[root@Linux]$ cat f2I am f1 file[root@Linux]$ cat f3I am f1 file[root@Linux]$ rm -f f1[root@Linux]$ cat f2I am f1 file[root@Linux]$ cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1文件无效。 3.总结依此您可以做一些相关的测试，可以得到以下全部结论： 1).删除符号连接f3,对f1,f2无影响； 2).删除硬连接f2，对f1,f3也无影响； 3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 本文摘自互联网，侵删。","link":"/2019-05-29-linux-symbolic-link/"},{"title":"MySQL权限管理","text":"MySQL中的账号与权限管理 权限系统的工作原理MySQL权限系统通过下面两个阶段进行认证： 对连接的用户进行身份认证，合法的用户通过认证、不合法的用户拒绝连接。 对通过认证的合法用户赋予相应的权限，用户可以在这些权限范围内对数据库做相应的操作。 对于身份，MySQL是通过IP地址和用户名联合进行确认的，例如MySQL安装默认创建的用户root@localhost表示用户root只能从本地（localhost）进行连接才可以通过认证，此用户从其他任何主机对数据库进行的连接都将被拒绝。也就是说，同样的一个用户名，如果来自不同的IP地址，则MySQL将其视为不同的用户。 MySQL的权限表在数据库启动地时候就载入内存，当用户通过身份认证后，就在内存中进行相应权限的存取，这样，此用户就可以在数据库中做权限范围内的各种操作了。 权限表系统会用到名叫“mysql”数据库（安装MySQL时被创建）中user表作为权限表 我们看看user表的结构（注：本文示例使用的是MySQL5.7.25版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; desc user;+------------------------+-----------------------------------+------+-----+-----------------------+-------+| Field | Type | Null | Key | Default | Extra |+------------------------+-----------------------------------+------+-----+-----------------------+-------+| Host | char(60) | NO | PRI | | || User | char(32) | NO | PRI | | || Select_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Insert_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Update_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Delete_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Drop_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Reload_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Shutdown_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Process_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || File_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Grant_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || References_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Index_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Alter_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Show_db_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Super_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_tmp_table_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Lock_tables_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Execute_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Repl_slave_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Repl_client_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_view_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Show_view_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_routine_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Alter_routine_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_user_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Event_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Trigger_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || Create_tablespace_priv | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || ssl_type | enum(&apos;&apos;,&apos;ANY&apos;,&apos;X509&apos;,&apos;SPECIFIED&apos;) | NO | | | || ssl_cipher | blob | NO | | NULL | || x509_issuer | blob | NO | | NULL | || x509_subject | blob | NO | | NULL | || max_questions | int(11) unsigned | NO | | 0 | || max_updates | int(11) unsigned | NO | | 0 | || max_connections | int(11) unsigned | NO | | 0 | || max_user_connections | int(11) unsigned | NO | | 0 | || plugin | char(64) | NO | | mysql_native_password | || authentication_string | text | YES | | NULL | || password_expired | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | || password_last_changed | timestamp | YES | | NULL | || password_lifetime | smallint(5) unsigned | YES | | NULL | || account_locked | enum(&apos;N&apos;,&apos;Y&apos;) | NO | | N | |+------------------------+-----------------------------------+------+-----+-----------------------+-------+45 rows in set (0.00 sec) 当用户进行连接的时候，权限表的存取过程有以下现个阶段。 先从user表中的Host、User、authentication_string(密码)、password_expired和password_lifetime这几个字段中判断连接的IP、用户名和密码是否存在于表中，如果存在，则通过身份验证，否则拒绝连接。 如果验证通过，再通过以_priv结尾的那些枚举字段（这些都是用户的权限开关（Y/N））得到用户拥有的权限。 账号管理账号管理主要包括账号的创建、权限更改和账号的删除。用户连接数据库的第一步都从账号创建开始。 有两种方法可以用来创建账号：使用GRANT语法创建或者直接操作授权表，但更推荐使用第一种方法，因为操作简单，出错几率更少。 我们用几个例子来说明吧： 创建用户 创建用户tom，权限为可以在所有数据库上执行所有权限，只能从本地进行连接。 1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO tom@localhost IDENTIFIED BY &apos;tompassword&apos; WITH GRANT OPTION; 如果你执行这个语句碰到以下错误：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements。这个是密码策略的问题，请设置比较复杂的密码，或者修改密码策略，这里就不详细说了。 GRANT命令说明： ALL PRIVILEGES是表示所有权限，你也可以使用select、update等权限。 ON用来指定权限针对哪些库和表，格式是数据库名.表名，这里*.*表示所有数据库和所有表。 TO 表示将权限赋予某个用户。tom@localhost，表示tom用户，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方。注意：这里%有的版本不包括本地，以前碰到过给某个用户设置了%允许任何地方登录，但是在本地登录不了，这个和版本有关系，遇到这个问题再加一个localhost的用户就可以了。 IDENTIFIED BY 指定用户的登录密码， 这里'tompassword'就是用户tom的密码。 WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人。注意：经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其它用户授权。 备注：可以使用GRANT重复给用户添加权限，权限叠加，比如你先给用户添加一个select权限，然后又给用户添加一个insert权限，那么该用户就同时拥有了select和insert权限。 使用GRANT操作用户权限之后，再使用FLUSH PRIVILEGES命令来刷新权限使其立即生效 12mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 查看用户的权限 直接使用SHOW GRANTS默认查看root@localhost的权限 12345678mysql&gt; SHOW GRANTS;+---------------------------------------------------------------------+| Grants for root@localhost |+---------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION || GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |+---------------------------------------------------------------------+2 rows in set (0.01 sec) 查看某个用户的权限 1234567mysql&gt; SHOW GRANTS FOR tom@localhost;+----------------------------------------------------------------------+| Grants for tom@localhost |+----------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO &apos;tom&apos;@&apos;localhost&apos; WITH GRANT OPTION |+----------------------------------------------------------------------+1 row in set (0.00 sec) 收回权限 12mysql&gt; REVOKE DELETE ON *.* FROM &apos;tom&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec) 对用户账户重命名 12mysql&gt; RENAME USER tom@localhost to jerry@localhost;Query OK, 0 rows affected (0.00 sec) 删除用户 12mysql&gt; DROP USER jerry@localhost;Query OK, 0 rows affected (0.01 sec) 修改和重置密码 用SET PASSWORD命令修改密码 12mysql&gt; SET PASSWORD FOR root@localhost = PASSWORD(&apos;123456&apos;);Query OK, 0 rows affected, 1 warning (0.01 sec) 直接修改user表 123456mysql&gt; UPDATE user SET authentication_string=PASSWORD(&apos;123456root&apos;) WHERE user=&apos;root&apos; and host=&apos;localhost&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 在未登录mysql的情况下用mysqladmin命令修改密码 1$ mysqladmin -uroot -p123456root password 123321 在丢失root密码的时候关闭mysql服务（根据你自己的操作系统自行关闭），然后跳过权限认证启动mysql服务 1$ mysqld_safe --skip-grant-tables &amp; 无密码登陆 1$ mysql -uroot 进入之后使用上面直接修改user表的方法修改root用户的密码 最后杀掉mysqld_safe和mysqld的进程 重新启动mysql服务，用新的密码登陆吧。","link":"/2019-06-10-mysql-user/"},{"title":"阳光明媚，时光静好","text":"起了个老早，去练车，本来睡不好，还有点情绪，在下车过桥时突然发现早上的阳光格外的好。","link":"/2019-06-15-good-morning/"},{"title":"SSH使用密码自动登录脚本","text":"分享一个ssh使用密码登录的脚本 写个脚本autologin.sh内容如下： 1234567891011#!/usr/bin/expect -fset user [lindex $argv 0]set host [lindex $argv 1]set password [lindex $argv 2]set timeout -1spawn ssh $user@$hostexpect \"password:*\"send \"$password\\r\"interactexpect eof 并给这个脚本可执行权限 1chmod +x ./autologin.sh 使用方法：假如平时使用ssh root@127.0.0.1,然后输入密码123456登录 现在用这个脚本就是 1./autologin.sh root 127.0.0.1 123456 挺方便的吧～","link":"/2019-08-28-ssh-autologin/"}],"tags":[{"name":"听风雨","slug":"听风雨","link":"/tags/%E5%90%AC%E9%A3%8E%E9%9B%A8/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"岁月静好","slug":"岁月静好","link":"/tags/%E5%B2%81%E6%9C%88%E9%9D%99%E5%A5%BD/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"百度地图","slug":"百度地图","link":"/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"EFI","slug":"EFI","link":"/tags/EFI/"},{"name":"Archlinux","slug":"Archlinux","link":"/tags/Archlinux/"},{"name":"Win10","slug":"Win10","link":"/tags/Win10/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"MSYS2","slug":"MSYS2","link":"/tags/MSYS2/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"虚拟化","slug":"虚拟化","link":"/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"容器","slug":"容器","link":"/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"UEditor","slug":"UEditor","link":"/tags/UEditor/"},{"name":"互联网","slug":"互联网","link":"/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Webhook","slug":"Webhook","link":"/tags/Webhook/"},{"name":"Composer","slug":"Composer","link":"/tags/Composer/"},{"name":"搜索引擎","slug":"搜索引擎","link":"/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"站内搜索","slug":"站内搜索","link":"/tags/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"name":"Yii2","slug":"Yii2","link":"/tags/Yii2/"},{"name":"jupyter","slug":"jupyter","link":"/tags/jupyter/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"github-issue","slug":"github-issue","link":"/tags/github-issue/"},{"name":"gitment","slug":"gitment","link":"/tags/gitment/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"pcntl","slug":"pcntl","link":"/tags/pcntl/"},{"name":"AlpineLinux","slug":"AlpineLinux","link":"/tags/AlpineLinux/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"全文搜索","slug":"全文搜索","link":"/tags/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/tags/ElasticSearch/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"MathJax","slug":"MathJax","link":"/tags/MathJax/"},{"name":"LaTex","slug":"LaTex","link":"/tags/LaTex/"}],"categories":[{"name":"听风雨","slug":"听风雨","link":"/categories/%E5%90%AC%E9%A3%8E%E9%9B%A8/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"岁月静好","slug":"岁月静好","link":"/categories/%E5%B2%81%E6%9C%88%E9%9D%99%E5%A5%BD/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"资源","slug":"资源","link":"/categories/%E8%B5%84%E6%BA%90/"},{"name":"HTML5","slug":"JavaScript/HTML5","link":"/categories/JavaScript/HTML5/"},{"name":"互联网","slug":"互联网","link":"/categories/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"搜索引擎","slug":"搜索引擎","link":"/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"Git","slug":"Linux/Git","link":"/categories/Linux/Git/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"github-issue","slug":"github-issue","link":"/categories/github-issue/"},{"name":"SSH","slug":"SSH","link":"/categories/SSH/"},{"name":"PHP","slug":"Docker/PHP","link":"/categories/Docker/PHP/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Queue","slug":"Queue","link":"/categories/Queue/"},{"name":"全文搜索","slug":"全文搜索","link":"/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"PHP","slug":"JavaScript/PHP","link":"/categories/JavaScript/PHP/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"PHP","slug":"Git/PHP","link":"/categories/Git/PHP/"},{"name":"PHP","slug":"Queue/PHP","link":"/categories/Queue/PHP/"},{"name":"JavaScript","slug":"数学/JavaScript","link":"/categories/%E6%95%B0%E5%AD%A6/JavaScript/"}]}